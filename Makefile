SHELL         = /bin/bash
CFG           = .env
DCAPE_USED    = 1

TZ           ?= $(shell cat /etc/timezone)
DCINC         = docker-compose.inc.yml

# check this files for update docker-compose.yml
DCFILES       = $(shell find apps/ -name $(DCINC) -print | sort)

PROJECT_NAME ?= dcape
DOMAIN       ?= dev.lan
APPS_SYS     ?= db
APPS         ?= traefik portainer enfist cis
# Postgresql superuser Database user password
PG_DB_PASS   ?= $(shell < /dev/urandom tr -dc A-Za-z0-9 | head -c14; echo)
PG_ENCODING  ?= $(LANG)

# Config store url
ENFIST_URL   ?= http://enfist:8080/rpc


# if exists - load old values
-include $(CFG).bak
export


-include $(CFG)
export

include apps/*/Makefile

.PHONY: deps init-master init-slave init-local init apply up reup down dc db-create db-drop env-get env-set help

all: help

init-master: APPS = traefik-acme gitea portainer enfist cis
init-master: init

init-slave: APPS = traefik-acme portainer enfist cis
init-slave: init

init-local: APPS = traefik gitea portainer enfist cis
init-local: init

define CONFIG_DEF
# dcape config file, generated by make init

# General settings

# containers name prefix
PROJECT_NAME=$(PROJECT_NAME)

# Default domain
DOMAIN=$(DOMAIN)

# App list, for use in make only
APPS="$(shell echo $(APPS))"

# containers timezone
TZ=$(TZ)

# Postgresql database encoding
PG_ENCODING=$(PG_ENCODING)

# db (postgresql)
PG_DB_PASS=$(PG_DB_PASS)

endef
export CONFIG_DEF

## установка зависимостей
deps:
	@echo "*** $@ ***"
	which docker > /dev/null || wget -qO- https://get.docker.com/ | sh

## Initially create .enc file with defaults
init:
	@echo "*** $@ $(APPS) ***"
	@[ -d var/data ] || mkdir -p var/data
	@[ -f .env ] && { echo ".env already exists. Skipping" ; exit 1 ; } || true
	@echo "$$CONFIG_DEF" > .env
	@for f in $(shell echo $(APPS)) ; do echo $$f ; $(MAKE) -s $${f}-init ; done

## Apply config to app files & db
apply:
	@echo "*** $@ $(APPS) ***"
	@$(MAKE) -s dc CMD="up -d $(APPS_SYS)" || echo ""
	@for f in $(shell echo $(APPS)) ; do $(MAKE) -s $${f}-apply ; done


# build file from app templates
docker-compose.yml: $(DCINC) $(DCFILES)
	@echo "*** $@ ***"
	@echo "# WARNING! This file was generated by make. DO NOT EDIT" > $@
	@cat $(DCINC) >> $@
	@for f in $(shell echo $(APPS)) ; do cat apps/$$f/$(DCINC) >> $@ ; done

## старт контейнеров
up:
up: CMD=up -d $(APPS_SYS) $(shell echo $(APPS))
up: dc

## рестарт контейнеров
reup:
reup: CMD=up --force-recreate -d $(APPS_SYS) $(shell echo $(APPS))
reup: dc

## остановка и удаление всех контейнеров
down:
down: CMD=down
down: dc

# ------------------------------------------------------------------------------

# $$PWD используется для того, чтобы текущий каталог был доступен в контейнере по тому же пути
# и относительные тома новых контейнеров могли его использовать
## run docker-compose
dc: docker-compose.yml
	@docker run --rm -t -i \
	  -v /var/run/docker.sock:/var/run/docker.sock \
	  -v $$PWD:$$PWD \
	  -w $$PWD \
	  docker/compose:1.14.0 \
	  -p $$PROJECT_NAME \
	  $(CMD)

# ------------------------------------------------------------------------------

## create database and user
db-create:
	@echo "*** $@ ***" \
	&& varname=$(NAME)_DB_PASS && pass=$${!varname} \
	&& varname=$(NAME)_DB_TAG && dbname=$${!varname} \
	&& CONTAINER=$${PROJECT_NAME}_db_1 \
	&& echo -n "Checking PG is ready..." \
	&& until [[ `docker inspect -f "{{.State.Health.Status}}" $$CONTAINER` == healthy ]] ; do sleep 1 ; echo -n "." ; done \
	&& echo "Ok" \
	&& docker exec -it $$CONTAINER psql -U postgres -c "CREATE USER \"$$dbname\" WITH PASSWORD '$$pass';" \
	&& docker exec -it $$CONTAINER psql -U postgres -c "CREATE DATABASE \"$$dbname\" OWNER \"$$dbname\";"

## drop database and user
db-drop:
	@echo "*** $@ ***" \
	&& varname=$(NAME)_DB_TAG && dbname=$${!varname} \
	&& CONTAINER=$${PROJECT_NAME}_db_1 \
	&& docker exec -it $$CONTAINER psql -U postgres -c "DROP DATABASE \"$$dbname\";" \
	&& docker exec -it $$CONTAINER psql -U postgres -c "DROP USER \"$$dbname\";"

psql:
	@CONTAINER=$${PROJECT_NAME}_db_1 \
	  && docker exec -it $$CONTAINER psql -U postgres

# ------------------------------------------------------------------------------
# .env file store

## get env tag from store, `make env-get TAG=app--config--tag`
env-get:
	@[[ "$(TAG)" ]] || { echo "Error: Tag value required" ; exit 1 ;}
	@echo "Getting env into $(TAG)"
	@docker exec -ti $${PROJECT_NAME}_webhook_1 curl -gs $${ENFIST_URL}/tag_vars?a_code=$(TAG) \
	  | jq -r '.result[0].tag_vars' > $(TAG).env
# | sed 's/\\n/\n/g' > $(TAG).env

#  | jq -r .result[0].tag_vars | sed 's/\\n/\n/g' > $(TAG).env

## set env tag in store, `make env-set TAG=app--config--tag`
env-set:
	@[[ "$(TAG)" ]] || { echo "Error: Tag value required" ; exit 1 ;}
	@echo "Setting $(TAG) from file" \
	&& jq -R -sc ". | {\"a_code\":\"$(TAG)\",\"a_data\":.}" < $(TAG).env | \
	  docker exec -i $${PROJECT_NAME}_webhook_1 curl -gsd @- $${ENFIST_URL}/tag_set > /dev/null

# ------------------------------------------------------------------------------

## delete unused docker images w/o name
clean-noname:
	docker rmi $$(docker images | grep "<none>" | awk "{print \$$3}")
#docker images -q -f dangling=true

## delete docker dangling volumes
clean-volume:
	docker volume rm $$(docker volume ls -qf dangling=true)

# ------------------------------------------------------------------------------

help:
	@grep -A 1 "^##" Makefile | less

##
## Press 'q' for exit
##
